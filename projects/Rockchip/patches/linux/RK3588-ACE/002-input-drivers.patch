diff -rupN linux.orig/Makefile linux/Makefile
--- linux.orig/Makefile	2024-02-21 01:57:23.445573377 +0000
+++ linux/Makefile	2024-02-22 16:21:29.661040043 +0000
@@ -1075,7 +1075,7 @@ endif
 KBUILD_CFLAGS   += -Werror=date-time
 
 # enforce correct pointer usage
-KBUILD_CFLAGS   += $(call cc-option,-Werror=incompatible-pointer-types)
+#KBUILD_CFLAGS   += $(call cc-option,-Werror=incompatible-pointer-types)
 
 # Require designated initializers for all marked structures
 KBUILD_CFLAGS   += $(call cc-option,-Werror=designated-init)
diff -rupN linux.orig/drivers/iio/adc/ti-ads1015.c linux/drivers/iio/adc/ti-ads1015.c
--- linux.orig/drivers/iio/adc/ti-ads1015.c	2024-02-21 01:57:24.113595238 +0000
+++ linux/drivers/iio/adc/ti-ads1015.c	2024-02-22 16:18:15.319056297 +0000
@@ -76,15 +76,10 @@
 #define ADS1015_DEFAULT_DATA_RATE	4
 #define ADS1015_DEFAULT_CHAN		0
 
-struct ads1015_chip_data {
-	struct iio_chan_spec const	*channels;
-	int				num_channels;
-	const struct iio_info		*info;
-	const int			*data_rate;
-	const int			data_rate_len;
-	const int			*scale;
-	const int			scale_len;
-	bool				has_comparator;
+enum chip_ids {
+	ADSXXXX = 0,
+	ADS1015,
+	ADS1115,
 };
 
 enum ads1015_channels {
@@ -99,11 +94,11 @@ enum ads1015_channels {
 	ADS1015_TIMESTAMP,
 };
 
-static const int ads1015_data_rate[] = {
+static const unsigned int ads1015_data_rate[] = {
 	128, 250, 490, 920, 1600, 2400, 3300, 3300
 };
 
-static const int ads1115_data_rate[] = {
+static const unsigned int ads1115_data_rate[] = {
 	8, 16, 32, 64, 128, 250, 475, 860
 };
 
@@ -111,28 +106,10 @@ static const int ads1115_data_rate[] = {
  * Translation from PGA bits to full-scale positive and negative input voltage
  * range in mV
  */
-static const int ads1015_fullscale_range[] = {
+static int ads1015_fullscale_range[] = {
 	6144, 4096, 2048, 1024, 512, 256, 256, 256
 };
 
-static const int ads1015_scale[] = {	/* 12bit ADC */
-	256, 11,
-	512, 11,
-	1024, 11,
-	2048, 11,
-	4096, 11,
-	6144, 11
-};
-
-static const int ads1115_scale[] = {	/* 16bit ADC */
-	256, 15,
-	512, 15,
-	1024, 15,
-	2048, 15,
-	4096, 15,
-	6144, 15
-};
-
 /*
  * Translation from COMP_QUE field value to the number of successive readings
  * exceed the threshold values before an interrupt is generated
@@ -157,53 +134,71 @@ static const struct iio_event_spec ads10
 	},
 };
 
-/*
- * Compile-time check whether _fitbits can accommodate up to _testbits
- * bits. Returns _fitbits on success, fails to compile otherwise.
- *
- * The test works such that it multiplies constant _fitbits by constant
- * double-negation of size of a non-empty structure, i.e. it multiplies
- * constant _fitbits by constant 1 in each successful compilation case.
- * The non-empty structure may contain C11 _Static_assert(), make use of
- * this and place the kernel variant of static assert in there, so that
- * it performs the compile-time check for _testbits <= _fitbits. Note
- * that it is not possible to directly use static_assert in compound
- * statements, hence this convoluted construct.
- */
-#define FIT_CHECK(_testbits, _fitbits)					\
-	(								\
-		(_fitbits) *						\
-		!!sizeof(struct {					\
-			static_assert((_testbits) <= (_fitbits));	\
-			int pad;					\
-		})							\
-	)
+#define ADS1015_V_CHAN(_chan, _addr) {				\
+	.type = IIO_VOLTAGE,					\
+	.indexed = 1,						\
+	.address = _addr,					\
+	.channel = _chan,					\
+	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |		\
+				BIT(IIO_CHAN_INFO_SCALE) |	\
+				BIT(IIO_CHAN_INFO_SAMP_FREQ),	\
+	.scan_index = _addr,					\
+	.scan_type = {						\
+		.sign = 's',					\
+		.realbits = 12,					\
+		.storagebits = 16,				\
+		.shift = 4,					\
+		.endianness = IIO_CPU,				\
+	},							\
+	.event_spec = ads1015_events,				\
+	.num_event_specs = ARRAY_SIZE(ads1015_events),		\
+	.datasheet_name = "AIN"#_chan,				\
+}
 
-#define ADS1015_V_CHAN(_chan, _addr, _realbits, _shift, _event_spec, _num_event_specs) { \
+#define ADS1015_V_DIFF_CHAN(_chan, _chan2, _addr) {		\
 	.type = IIO_VOLTAGE,					\
+	.differential = 1,					\
 	.indexed = 1,						\
 	.address = _addr,					\
 	.channel = _chan,					\
+	.channel2 = _chan2,					\
 	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |		\
 				BIT(IIO_CHAN_INFO_SCALE) |	\
 				BIT(IIO_CHAN_INFO_SAMP_FREQ),	\
-	.info_mask_shared_by_all_available =			\
+	.scan_index = _addr,					\
+	.scan_type = {						\
+		.sign = 's',					\
+		.realbits = 12,					\
+		.storagebits = 16,				\
+		.shift = 4,					\
+		.endianness = IIO_CPU,				\
+	},							\
+	.event_spec = ads1015_events,				\
+	.num_event_specs = ARRAY_SIZE(ads1015_events),		\
+	.datasheet_name = "AIN"#_chan"-AIN"#_chan2,		\
+}
+
+#define ADS1115_V_CHAN(_chan, _addr) {				\
+	.type = IIO_VOLTAGE,					\
+	.indexed = 1,						\
+	.address = _addr,					\
+	.channel = _chan,					\
+	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |		\
 				BIT(IIO_CHAN_INFO_SCALE) |	\
 				BIT(IIO_CHAN_INFO_SAMP_FREQ),	\
 	.scan_index = _addr,					\
 	.scan_type = {						\
 		.sign = 's',					\
-		.realbits = (_realbits),			\
-		.storagebits = FIT_CHECK((_realbits) + (_shift), 16),	\
-		.shift = (_shift),				\
+		.realbits = 16,					\
+		.storagebits = 16,				\
 		.endianness = IIO_CPU,				\
 	},							\
-	.event_spec = (_event_spec),				\
-	.num_event_specs = (_num_event_specs),			\
+	.event_spec = ads1015_events,				\
+	.num_event_specs = ARRAY_SIZE(ads1015_events),		\
 	.datasheet_name = "AIN"#_chan,				\
 }
 
-#define ADS1015_V_DIFF_CHAN(_chan, _chan2, _addr, _realbits, _shift, _event_spec, _num_event_specs) { \
+#define ADS1115_V_DIFF_CHAN(_chan, _chan2, _addr) {		\
 	.type = IIO_VOLTAGE,					\
 	.differential = 1,					\
 	.indexed = 1,						\
@@ -213,19 +208,15 @@ static const struct iio_event_spec ads10
 	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |		\
 				BIT(IIO_CHAN_INFO_SCALE) |	\
 				BIT(IIO_CHAN_INFO_SAMP_FREQ),	\
-	.info_mask_shared_by_all_available =			\
-				BIT(IIO_CHAN_INFO_SCALE) |	\
-				BIT(IIO_CHAN_INFO_SAMP_FREQ),	\
 	.scan_index = _addr,					\
 	.scan_type = {						\
 		.sign = 's',					\
-		.realbits = (_realbits),			\
-		.storagebits = FIT_CHECK((_realbits) + (_shift), 16),	\
-		.shift = (_shift),				\
+		.realbits = 16,					\
+		.storagebits = 16,				\
 		.endianness = IIO_CPU,				\
 	},							\
-	.event_spec = (_event_spec),				\
-	.num_event_specs = (_num_event_specs),			\
+	.event_spec = ads1015_events,				\
+	.num_event_specs = ARRAY_SIZE(ads1015_events),		\
 	.datasheet_name = "AIN"#_chan"-AIN"#_chan2,		\
 }
 
@@ -254,7 +245,7 @@ struct ads1015_data {
 	unsigned int comp_mode;
 	struct ads1015_thresh_data thresh_data[ADS1015_CHANNELS];
 
-	const struct ads1015_chip_data *chip;
+	unsigned int *data_rate;
 	/*
 	 * Set to true when the ADC is switched to the continuous-conversion
 	 * mode and exits from a power-down state.  This flag is used to avoid
@@ -282,91 +273,49 @@ static void ads1015_event_channel_disabl
 	data->event_channel = ADS1015_CHANNELS;
 }
 
-static const struct regmap_range ads1015_writeable_ranges[] = {
-	regmap_reg_range(ADS1015_CFG_REG, ADS1015_HI_THRESH_REG),
-};
-
-static const struct regmap_access_table ads1015_writeable_table = {
-	.yes_ranges = ads1015_writeable_ranges,
-	.n_yes_ranges = ARRAY_SIZE(ads1015_writeable_ranges),
-};
+static bool ads1015_is_writeable_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case ADS1015_CFG_REG:
+	case ADS1015_LO_THRESH_REG:
+	case ADS1015_HI_THRESH_REG:
+		return true;
+	default:
+		return false;
+	}
+}
 
 static const struct regmap_config ads1015_regmap_config = {
 	.reg_bits = 8,
 	.val_bits = 16,
 	.max_register = ADS1015_HI_THRESH_REG,
-	.wr_table = &ads1015_writeable_table,
-};
-
-static const struct regmap_range tla2024_writeable_ranges[] = {
-	regmap_reg_range(ADS1015_CFG_REG, ADS1015_CFG_REG),
-};
-
-static const struct regmap_access_table tla2024_writeable_table = {
-	.yes_ranges = tla2024_writeable_ranges,
-	.n_yes_ranges = ARRAY_SIZE(tla2024_writeable_ranges),
-};
-
-static const struct regmap_config tla2024_regmap_config = {
-	.reg_bits = 8,
-	.val_bits = 16,
-	.max_register = ADS1015_CFG_REG,
-	.wr_table = &tla2024_writeable_table,
+	.writeable_reg = ads1015_is_writeable_reg,
 };
 
 static const struct iio_chan_spec ads1015_channels[] = {
-	ADS1015_V_DIFF_CHAN(0, 1, ADS1015_AIN0_AIN1, 12, 4,
-			    ads1015_events, ARRAY_SIZE(ads1015_events)),
-	ADS1015_V_DIFF_CHAN(0, 3, ADS1015_AIN0_AIN3, 12, 4,
-			    ads1015_events, ARRAY_SIZE(ads1015_events)),
-	ADS1015_V_DIFF_CHAN(1, 3, ADS1015_AIN1_AIN3, 12, 4,
-			    ads1015_events, ARRAY_SIZE(ads1015_events)),
-	ADS1015_V_DIFF_CHAN(2, 3, ADS1015_AIN2_AIN3, 12, 4,
-			    ads1015_events, ARRAY_SIZE(ads1015_events)),
-	ADS1015_V_CHAN(0, ADS1015_AIN0, 12, 4,
-		       ads1015_events, ARRAY_SIZE(ads1015_events)),
-	ADS1015_V_CHAN(1, ADS1015_AIN1, 12, 4,
-		       ads1015_events, ARRAY_SIZE(ads1015_events)),
-	ADS1015_V_CHAN(2, ADS1015_AIN2, 12, 4,
-		       ads1015_events, ARRAY_SIZE(ads1015_events)),
-	ADS1015_V_CHAN(3, ADS1015_AIN3, 12, 4,
-		       ads1015_events, ARRAY_SIZE(ads1015_events)),
+	ADS1015_V_DIFF_CHAN(0, 1, ADS1015_AIN0_AIN1),
+	ADS1015_V_DIFF_CHAN(0, 3, ADS1015_AIN0_AIN3),
+	ADS1015_V_DIFF_CHAN(1, 3, ADS1015_AIN1_AIN3),
+	ADS1015_V_DIFF_CHAN(2, 3, ADS1015_AIN2_AIN3),
+	ADS1015_V_CHAN(0, ADS1015_AIN0),
+	ADS1015_V_CHAN(1, ADS1015_AIN1),
+	ADS1015_V_CHAN(2, ADS1015_AIN2),
+	ADS1015_V_CHAN(3, ADS1015_AIN3),
 	IIO_CHAN_SOFT_TIMESTAMP(ADS1015_TIMESTAMP),
 };
 
 static const struct iio_chan_spec ads1115_channels[] = {
-	ADS1015_V_DIFF_CHAN(0, 1, ADS1015_AIN0_AIN1, 16, 0,
-			    ads1015_events, ARRAY_SIZE(ads1015_events)),
-	ADS1015_V_DIFF_CHAN(0, 3, ADS1015_AIN0_AIN3, 16, 0,
-			    ads1015_events, ARRAY_SIZE(ads1015_events)),
-	ADS1015_V_DIFF_CHAN(1, 3, ADS1015_AIN1_AIN3, 16, 0,
-			    ads1015_events, ARRAY_SIZE(ads1015_events)),
-	ADS1015_V_DIFF_CHAN(2, 3, ADS1015_AIN2_AIN3, 16, 0,
-			    ads1015_events, ARRAY_SIZE(ads1015_events)),
-	ADS1015_V_CHAN(0, ADS1015_AIN0, 16, 0,
-		       ads1015_events, ARRAY_SIZE(ads1015_events)),
-	ADS1015_V_CHAN(1, ADS1015_AIN1, 16, 0,
-		       ads1015_events, ARRAY_SIZE(ads1015_events)),
-	ADS1015_V_CHAN(2, ADS1015_AIN2, 16, 0,
-		       ads1015_events, ARRAY_SIZE(ads1015_events)),
-	ADS1015_V_CHAN(3, ADS1015_AIN3, 16, 0,
-		       ads1015_events, ARRAY_SIZE(ads1015_events)),
+	ADS1115_V_DIFF_CHAN(0, 1, ADS1015_AIN0_AIN1),
+	ADS1115_V_DIFF_CHAN(0, 3, ADS1015_AIN0_AIN3),
+	ADS1115_V_DIFF_CHAN(1, 3, ADS1015_AIN1_AIN3),
+	ADS1115_V_DIFF_CHAN(2, 3, ADS1015_AIN2_AIN3),
+	ADS1115_V_CHAN(0, ADS1015_AIN0),
+	ADS1115_V_CHAN(1, ADS1015_AIN1),
+	ADS1115_V_CHAN(2, ADS1015_AIN2),
+	ADS1115_V_CHAN(3, ADS1015_AIN3),
 	IIO_CHAN_SOFT_TIMESTAMP(ADS1015_TIMESTAMP),
 };
 
-static const struct iio_chan_spec tla2024_channels[] = {
-	ADS1015_V_DIFF_CHAN(0, 1, ADS1015_AIN0_AIN1, 12, 4, NULL, 0),
-	ADS1015_V_DIFF_CHAN(0, 3, ADS1015_AIN0_AIN3, 12, 4, NULL, 0),
-	ADS1015_V_DIFF_CHAN(1, 3, ADS1015_AIN1_AIN3, 12, 4, NULL, 0),
-	ADS1015_V_DIFF_CHAN(2, 3, ADS1015_AIN2_AIN3, 12, 4, NULL, 0),
-	ADS1015_V_CHAN(0, ADS1015_AIN0, 12, 4, NULL, 0),
-	ADS1015_V_CHAN(1, ADS1015_AIN1, 12, 4, NULL, 0),
-	ADS1015_V_CHAN(2, ADS1015_AIN2, 12, 4, NULL, 0),
-	ADS1015_V_CHAN(3, ADS1015_AIN3, 12, 4, NULL, 0),
-	IIO_CHAN_SOFT_TIMESTAMP(ADS1015_TIMESTAMP),
-};
-
-
 #ifdef CONFIG_PM
 static int ads1015_set_power_state(struct ads1015_data *data, bool on)
 {
@@ -374,7 +323,9 @@ static int ads1015_set_power_state(struc
 	struct device *dev = regmap_get_device(data->regmap);
 
 	if (on) {
-		ret = pm_runtime_resume_and_get(dev);
+		ret = pm_runtime_get_sync(dev);
+		if (ret < 0)
+			pm_runtime_put_noidle(dev);
 	} else {
 		pm_runtime_mark_last_busy(dev);
 		ret = pm_runtime_put_autosuspend(dev);
@@ -395,7 +346,6 @@ static int ads1015_set_power_state(struc
 static
 int ads1015_get_adc_result(struct ads1015_data *data, int chan, int *val)
 {
-	const int *data_rate = data->chip->data_rate;
 	int ret, pga, dr, dr_old, conv_time;
 	unsigned int old, mask, cfg;
 
@@ -430,8 +380,8 @@ int ads1015_get_adc_result(struct ads101
 	}
 	if (data->conv_invalid) {
 		dr_old = (old & ADS1015_CFG_DR_MASK) >> ADS1015_CFG_DR_SHIFT;
-		conv_time = DIV_ROUND_UP(USEC_PER_SEC, data_rate[dr_old]);
-		conv_time += DIV_ROUND_UP(USEC_PER_SEC, data_rate[dr]);
+		conv_time = DIV_ROUND_UP(USEC_PER_SEC, data->data_rate[dr_old]);
+		conv_time += DIV_ROUND_UP(USEC_PER_SEC, data->data_rate[dr]);
 		conv_time += conv_time / 10; /* 10% internal clock inaccuracy */
 		usleep_range(conv_time, conv_time + 1);
 		data->conv_invalid = false;
@@ -497,8 +447,8 @@ static int ads1015_set_data_rate(struct
 {
 	int i;
 
-	for (i = 0; i < data->chip->data_rate_len; i++) {
-		if (data->chip->data_rate[i] == rate) {
+	for (i = 0; i < ARRAY_SIZE(ads1015_data_rate); i++) {
+		if (data->data_rate[i] == rate) {
 			data->channel_data[chan].data_rate = i;
 			return 0;
 		}
@@ -507,32 +457,6 @@ static int ads1015_set_data_rate(struct
 	return -EINVAL;
 }
 
-static int ads1015_read_avail(struct iio_dev *indio_dev,
-			      struct iio_chan_spec const *chan,
-			      const int **vals, int *type, int *length,
-			      long mask)
-{
-	struct ads1015_data *data = iio_priv(indio_dev);
-
-	if (chan->type != IIO_VOLTAGE)
-		return -EINVAL;
-
-	switch (mask) {
-	case IIO_CHAN_INFO_SCALE:
-		*type = IIO_VAL_FRACTIONAL_LOG2;
-		*vals =  data->chip->scale;
-		*length = data->chip->scale_len;
-		return IIO_AVAIL_LIST;
-	case IIO_CHAN_INFO_SAMP_FREQ:
-		*type = IIO_VAL_INT;
-		*vals = data->chip->data_rate;
-		*length = data->chip->data_rate_len;
-		return IIO_AVAIL_LIST;
-	default:
-		return -EINVAL;
-	}
-}
-
 static int ads1015_read_raw(struct iio_dev *indio_dev,
 			    struct iio_chan_spec const *chan, int *val,
 			    int *val2, long mask)
@@ -542,7 +466,9 @@ static int ads1015_read_raw(struct iio_d
 
 	mutex_lock(&data->lock);
 	switch (mask) {
-	case IIO_CHAN_INFO_RAW:
+	case IIO_CHAN_INFO_RAW: {
+		int shift = chan->scan_type.shift;
+
 		ret = iio_device_claim_direct_mode(indio_dev);
 		if (ret)
 			break;
@@ -563,8 +489,7 @@ static int ads1015_read_raw(struct iio_d
 			goto release_direct;
 		}
 
-		*val = sign_extend32(*val >> chan->scan_type.shift,
-				     chan->scan_type.realbits - 1);
+		*val = sign_extend32(*val >> shift, 15 - shift);
 
 		ret = ads1015_set_power_state(data, false);
 		if (ret < 0)
@@ -574,6 +499,7 @@ static int ads1015_read_raw(struct iio_d
 release_direct:
 		iio_device_release_direct_mode(indio_dev);
 		break;
+	}
 	case IIO_CHAN_INFO_SCALE:
 		idx = data->channel_data[chan->address].pga;
 		*val = ads1015_fullscale_range[idx];
@@ -582,7 +508,7 @@ release_direct:
 		break;
 	case IIO_CHAN_INFO_SAMP_FREQ:
 		idx = data->channel_data[chan->address].data_rate;
-		*val = data->chip->data_rate[idx];
+		*val = data->data_rate[idx];
 		ret = IIO_VAL_INT;
 		break;
 	default:
@@ -642,7 +568,7 @@ static int ads1015_read_event(struct iio
 		dr = data->channel_data[chan->address].data_rate;
 		comp_queue = data->thresh_data[chan->address].comp_queue;
 		period = ads1015_comp_queue[comp_queue] *
-			USEC_PER_SEC / data->chip->data_rate[dr];
+			USEC_PER_SEC / data->data_rate[dr];
 
 		*val = period / USEC_PER_SEC;
 		*val2 = period % USEC_PER_SEC;
@@ -664,7 +590,6 @@ static int ads1015_write_event(struct ii
 	int val2)
 {
 	struct ads1015_data *data = iio_priv(indio_dev);
-	const int *data_rate = data->chip->data_rate;
 	int realbits = chan->scan_type.realbits;
 	int ret = 0;
 	long long period;
@@ -690,7 +615,7 @@ static int ads1015_write_event(struct ii
 
 		for (i = 0; i < ARRAY_SIZE(ads1015_comp_queue) - 1; i++) {
 			if (period <= ads1015_comp_queue[i] *
-					USEC_PER_SEC / data_rate[dr])
+					USEC_PER_SEC / data->data_rate[dr])
 				break;
 		}
 		data->thresh_data[chan->address].comp_queue = i;
@@ -881,20 +806,54 @@ static const struct iio_buffer_setup_ops
 	.validate_scan_mask = &iio_validate_scan_mask_onehot,
 };
 
+static IIO_CONST_ATTR_NAMED(ads1015_scale_available, scale_available,
+	"3 2 1 0.5 0.25 0.125");
+static IIO_CONST_ATTR_NAMED(ads1115_scale_available, scale_available,
+	"0.1875 0.125 0.0625 0.03125 0.015625 0.007813");
+
+static IIO_CONST_ATTR_NAMED(ads1015_sampling_frequency_available,
+	sampling_frequency_available, "128 250 490 920 1600 2400 3300");
+static IIO_CONST_ATTR_NAMED(ads1115_sampling_frequency_available,
+	sampling_frequency_available, "8 16 32 64 128 250 475 860");
+
+static struct attribute *ads1015_attributes[] = {
+	&iio_const_attr_ads1015_scale_available.dev_attr.attr,
+	&iio_const_attr_ads1015_sampling_frequency_available.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group ads1015_attribute_group = {
+	.attrs = ads1015_attributes,
+};
+
+static struct attribute *ads1115_attributes[] = {
+	&iio_const_attr_ads1115_scale_available.dev_attr.attr,
+	&iio_const_attr_ads1115_sampling_frequency_available.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group ads1115_attribute_group = {
+	.attrs = ads1115_attributes,
+};
+
 static const struct iio_info ads1015_info = {
-	.read_avail	= ads1015_read_avail,
 	.read_raw	= ads1015_read_raw,
 	.write_raw	= ads1015_write_raw,
 	.read_event_value = ads1015_read_event,
 	.write_event_value = ads1015_write_event,
 	.read_event_config = ads1015_read_event_config,
 	.write_event_config = ads1015_write_event_config,
+	.attrs          = &ads1015_attribute_group,
 };
 
-static const struct iio_info tla2024_info = {
-	.read_avail	= ads1015_read_avail,
+static const struct iio_info ads1115_info = {
 	.read_raw	= ads1015_read_raw,
 	.write_raw	= ads1015_write_raw,
+	.read_event_value = ads1015_read_event,
+	.write_event_value = ads1015_write_event,
+	.read_event_config = ads1015_read_event_config,
+	.write_event_config = ads1015_write_event_config,
+	.attrs          = &ads1115_attribute_group,
 };
 
 static int ads1015_client_get_channels_config(struct i2c_client *client)
@@ -977,18 +936,12 @@ static int ads1015_set_conv_mode(struct
 static int ads1015_probe(struct i2c_client *client,
 			 const struct i2c_device_id *id)
 {
-	const struct ads1015_chip_data *chip;
 	struct iio_dev *indio_dev;
 	struct ads1015_data *data;
 	int ret;
+	enum chip_ids chip;
 	int i;
 
-	chip = device_get_match_data(&client->dev);
-	if (!chip)
-		chip = (const struct ads1015_chip_data *)id->driver_data;
-	if (!chip)
-		return dev_err_probe(&client->dev, -EINVAL, "Unknown chip\n");
-
 	indio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));
 	if (!indio_dev)
 		return -ENOMEM;
@@ -1001,12 +954,28 @@ static int ads1015_probe(struct i2c_clie
 	indio_dev->name = ADS1015_DRV_NAME;
 	indio_dev->modes = INDIO_DIRECT_MODE;
 
-	indio_dev->channels = chip->channels;
-	indio_dev->num_channels = chip->num_channels;
-	indio_dev->info = chip->info;
-	data->chip = chip;
-	data->event_channel = ADS1015_CHANNELS;
+	chip = (enum chip_ids)device_get_match_data(&client->dev);
+	if (chip == ADSXXXX)
+		chip = id->driver_data;
+	switch (chip) {
+	case ADS1015:
+		indio_dev->channels = ads1015_channels;
+		indio_dev->num_channels = ARRAY_SIZE(ads1015_channels);
+		indio_dev->info = &ads1015_info;
+		data->data_rate = (unsigned int *) &ads1015_data_rate;
+		break;
+	case ADS1115:
+		indio_dev->channels = ads1115_channels;
+		indio_dev->num_channels = ARRAY_SIZE(ads1115_channels);
+		indio_dev->info = &ads1115_info;
+		data->data_rate = (unsigned int *) &ads1115_data_rate;
+		break;
+	default:
+		dev_err(&client->dev, "Unknown chip %d\n", chip);
+		return -EINVAL;
+	}
 
+	data->event_channel = ADS1015_CHANNELS;
 	/*
 	 * Set default lower and upper threshold to min and max value
 	 * respectively.
@@ -1021,9 +990,7 @@ static int ads1015_probe(struct i2c_clie
 	/* we need to keep this ABI the same as used by hwmon ADS1015 driver */
 	ads1015_get_channels_config(client);
 
-	data->regmap = devm_regmap_init_i2c(client, chip->has_comparator ?
-					    &ads1015_regmap_config :
-					    &tla2024_regmap_config);
+	data->regmap = devm_regmap_init_i2c(client, &ads1015_regmap_config);
 	if (IS_ERR(data->regmap)) {
 		dev_err(&client->dev, "Failed to allocate register map\n");
 		return PTR_ERR(data->regmap);
@@ -1037,7 +1004,7 @@ static int ads1015_probe(struct i2c_clie
 		return ret;
 	}
 
-	if (client->irq && chip->has_comparator) {
+	if (client->irq) {
 		unsigned long irq_trig =
 			irqd_get_trigger_type(irq_get_irq_data(client->irq));
 		unsigned int cfg_comp_mask = ADS1015_CFG_COMP_QUE_MASK |
@@ -1094,22 +1061,19 @@ static int ads1015_probe(struct i2c_clie
 	return 0;
 }
 
-static void ads1015_remove(struct i2c_client *client)
+static int ads1015_remove(struct i2c_client *client)
 {
 	struct iio_dev *indio_dev = i2c_get_clientdata(client);
 	struct ads1015_data *data = iio_priv(indio_dev);
-	int ret;
 
 	iio_device_unregister(indio_dev);
 
 	pm_runtime_disable(&client->dev);
 	pm_runtime_set_suspended(&client->dev);
+	pm_runtime_put_noidle(&client->dev);
 
 	/* power down single shot mode */
-	ret = ads1015_set_conv_mode(data, ADS1015_SINGLESHOT);
-	if (ret)
-		dev_warn(&client->dev, "Failed to power down (%pe)\n",
-			 ERR_PTR(ret));
+	return ads1015_set_conv_mode(data, ADS1015_SINGLESHOT);
 }
 
 #ifdef CONFIG_PM
@@ -1140,51 +1104,22 @@ static const struct dev_pm_ops ads1015_p
 			   ads1015_runtime_resume, NULL)
 };
 
-static const struct ads1015_chip_data ads1015_data = {
-	.channels	= ads1015_channels,
-	.num_channels	= ARRAY_SIZE(ads1015_channels),
-	.info		= &ads1015_info,
-	.data_rate	= ads1015_data_rate,
-	.data_rate_len	= ARRAY_SIZE(ads1015_data_rate),
-	.scale		= ads1015_scale,
-	.scale_len	= ARRAY_SIZE(ads1015_scale),
-	.has_comparator	= true,
-};
-
-static const struct ads1015_chip_data ads1115_data = {
-	.channels	= ads1115_channels,
-	.num_channels	= ARRAY_SIZE(ads1115_channels),
-	.info		= &ads1015_info,
-	.data_rate	= ads1115_data_rate,
-	.data_rate_len	= ARRAY_SIZE(ads1115_data_rate),
-	.scale		= ads1115_scale,
-	.scale_len	= ARRAY_SIZE(ads1115_scale),
-	.has_comparator	= true,
-};
-
-static const struct ads1015_chip_data tla2024_data = {
-	.channels	= tla2024_channels,
-	.num_channels	= ARRAY_SIZE(tla2024_channels),
-	.info		= &tla2024_info,
-	.data_rate	= ads1015_data_rate,
-	.data_rate_len	= ARRAY_SIZE(ads1015_data_rate),
-	.scale		= ads1015_scale,
-	.scale_len	= ARRAY_SIZE(ads1015_scale),
-	.has_comparator	= false,
-};
-
 static const struct i2c_device_id ads1015_id[] = {
-	{ "ads1015", (kernel_ulong_t)&ads1015_data },
-	{ "ads1115", (kernel_ulong_t)&ads1115_data },
-	{ "tla2024", (kernel_ulong_t)&tla2024_data },
+	{"ads1015", ADS1015},
+	{"ads1115", ADS1115},
 	{}
 };
 MODULE_DEVICE_TABLE(i2c, ads1015_id);
 
 static const struct of_device_id ads1015_of_match[] = {
-	{ .compatible = "ti,ads1015", .data = &ads1015_data },
-	{ .compatible = "ti,ads1115", .data = &ads1115_data },
-	{ .compatible = "ti,tla2024", .data = &tla2024_data },
+	{
+		.compatible = "ti,ads1015",
+		.data = (void *)ADS1015
+	},
+	{
+		.compatible = "ti,ads1115",
+		.data = (void *)ADS1115
+	},
 	{}
 };
 MODULE_DEVICE_TABLE(of, ads1015_of_match);
