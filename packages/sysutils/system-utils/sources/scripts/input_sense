#!/bin/bash
# SPDX-License-Identifier: GPL-2.0-or-later
# Copyright (C) 2023 JELOS (https://github.com/JustEnoughLinuxOS)
#               2021-present pkegg

. /etc/profile

set -e
set -o pipefail

### Summary
#   This script listens to input events and takes actions.
###

DEBUG=false

### Define matching values from evtest.
FUNCTION_VOLUME_UP_EVENT='*(KEY_VOLUME*UP), value 1'  # Differentiate 'up' volume event
FUNCTION_VOLUME_DOWN_EVENT='*(KEY_VOLUME**DOWN), value 1' #Differentiate 'down' volume event

FUNCTION_MODIFIER_A_EVENT='*('${DEVICE_FUNC_KEYA_MODIFIER}'), value *'
FUNCTION_MODIFIER_B_EVENT='*('${DEVICE_FUNC_KEYB_MODIFIER}'), value *'

FUNCTION_HOTKEY_EVENT='*(BTN_TL), value *'
FUNCTION_SELECT_EVENT='*(BTN_SELECT), value *'
FUNCTION_START_EVENT='*(BTN_START), value *'

CONTROLLER_DISCONNECTED="*error reading: No such device"
DEVICE_DISCONNECTED="*error reading: No such device"

### Matches if a button was pressed (1), released (0) or held down (2)
PRESS='value [1-9]'
RELEASE='value 0'

### Function buttons should be defined as not pressed for later matching.
FN_A_PRESSED=false
FN_B_PRESSED=false

### Allow actions to be overriden in system.cfg
FN_A_ACTION_UP="$(get_setting fn_a.action.up)"
FN_A_ACTION_DOWN="$(get_setting fn_a.action.down)"

FN_B_ACTION_UP="$(get_setting fn_b.action.up)"
FN_B_ACTION_DOWN="$(get_setting fn_b.action.down)"

FN_AB_ACTION_UP="$(get_setting fn_ab.action.up)"
FN_AB_ACTION_DOWN="$(get_setting fn_ab.action.down)"

### Set sane defaults to manage volume, brightness, wireless on/off, and led on/off.
if [ -z "${FN_A_ACTION_UP}" ]
then
  FN_A_ACTION_UP="brightness up"
fi

if [ -z "${FN_A_ACTION_DOWN}" ]
then
  FN_A_ACTION_DOWN="brightness down"
fi

if [ -z "${FN_B_ACTION_UP}" ]
then
  FN_B_ACTION_UP="wifictl enable"
fi

if [ -z "${FN_B_ACTION_DOWN}" ]
then
  FN_B_ACTION_DOWN="wifictl disable"
fi

if [ -z "${FN_AB_ACTION_UP}" ]
then
  FN_AB_ACTION_UP="ledcontrol"
fi

if [ -z "${FN_AB_ACTION_DOWN}" ]
then
  FN_AB_ACTION_DOWN="ledcontrol poweroff"
fi

### Simple functions to execute button actions, including global kill.
execute_kill() {
  if [ -e "/tmp/.process-kill-data" ]
  then
    TO_KILL="$(cat /tmp/.process-kill-data)"
    ${DEBUG} && log $0 "Execute: killall ${TO_KILL}"
    killall ${TO_KILL} 2>/dev/null
  fi
}

execute_action() {
    ${DEBUG} && log $0 "FN_A_PRESSED = ${FN_A_PRESSED} | FN_B_PRESSED = ${FN_B_PRESSED} | VAL = ${1}"
    if [ "${FN_A_PRESSED}" = true ] && \
       [ "${FN_B_PRESSED}" = true ]
    then
        ${DEBUG} && log $0 "Executing FN_AB action"
        case ${1} in
            up)
                ${DEBUG} && log $0 "FN_AB (${FN_AB_ACTION_UP})"
                ${FN_AB_ACTION_UP}
            ;;
            down)
                ${DEBUG} && log $0 "FN_AB (${FN_AB_ACTION_DOWN})"
                ${FN_AB_ACTION_DOWN}
            ;;
        esac
    elif [ "${FN_A_PRESSED}" = true ] && \
         [ "${FN_B_PRESSED}" = false ]
    then
        ${DEBUG} && log $0 "Executing FN_A action"
        case ${1} in
            up)
                ${DEBUG} && log $0 "FN_A (${FN_A_ACTION_UP})"
                ${FN_A_ACTION_UP}
            ;;
            down)
                ${DEBUG} && log $0 "FN_A (${FN_A_ACTION_DOWN})"
                ${FN_A_ACTION_DOWN}
            ;;
        esac
    elif [ "${FN_A_PRESSED}" = false ] && \
         [ "${FN_B_PRESSED}" = true ]
    then
        ${DEBUG} && log $0 "Executing FN_B action"
        case ${1} in
            up)
                ${DEBUG} && log $0 "FN_B (${FN_B_ACTION_UP})"
                ${FN_B_ACTION_UP}
            ;;
            down)
                ${DEBUG} && log $0 "FN_B (${FN_B_ACTION_DOWN})"
                ${FN_B_ACTION_DOWN}
            ;;
        esac
    else
        ${DEBUG} && log $0 "Executing Volume action"
        volume ${1}
    fi
}

### Search the system for useful devices to monitor for inputs.
get_devices() {
  KJDEVS=false
  FOUNDKEYS=false
  FOUNDJOY=false
  RETRY=5
  while [ ${KJDEVS} = false ]
  do
    # Detect input devices automatically
    for DEV in /dev/input/ev*
    do
      unset SUPPORTS
      SUPPORTS=$(udevadm info ${DEV} | awk '/ID_INPUT_KEY=|ID_INPUT_JOYSTICK=/ {print $2}')
      if [ -n "${SUPPORTS}" ]
      then
        DEVICE=$(udevadm info ${DEV} | awk 'BEGIN {FS="="} /DEVNAME=/ {print $2}')
        INPUT_DEVICES+=("${DEVICE}")
        if [[ "${SUPPORTS}" =~ ID_INPUT_KEY ]]
        then
          ${DEBUG} && log $0 "Found Keyboard: ${DEVICE}"
          FOUNDKEYS=true
        elif [[ "${SUPPORTS}" =~ ID_INPUT_JOYSTICK ]]
        then
          ${DEBUG} && log $0 "Found Joystick: ${DEVICE}"
          FOUNDJOY=true
        fi
      fi
    done
    if [ "${FOUNDKEYS}" = "true" ] &&
       [ "${FOUNDJOY}" = "true" ]
    then
      ${DEBUG} && log $0 "Found all of the needed devices."
      KJDEVS=true
      break
    fi
    if [ "${RETRY}" -ge 5 ]
    then
      ${DEBUG} && log $0 "Did not find all of the needed devices, but that may be OK.  Breaking."
      break
    else
      RETRY=$(( ${RETRY} + 1 ))
    fi
    sleep 1
  done
}

get_devices

# If the input devices change, it may be a new controller
# so handle it here.
mkcontroller 2>/dev/null ||:


### Go into a cpu friendly loop that idles until a key is pressed.  Take action when a known pattern of keys are pressed together.
(
   for INPUT_DEVICE in ${INPUT_DEVICES[@]}
   do
     evtest "${INPUT_DEVICE}" 2>&1 &
   done
   wait
) | while read line; do
    case ${line} in
        (${CONTROLLER_DISCONNECTED})
        ${DEBUG} && log $0 "Reloading due to ${CONTROLLER_DEVICE} reattach..."
        get_devices
        ;;
        (${DEVICE_DISCONNECTED})
        ${DEBUG} && log $0 "Reloading due to ${DEVICE} reattach..."
        get_devices
        ;;
        (${FUNCTION_MODIFIER_A_EVENT})
           if [[ "${line}" =~ ${PRESS} ]]
           then
              ${DEBUG} && log $0 "${FUNCTION_MODIFIER_A_EVENT}: Pressed"
              FN_A_PRESSED=true
           elif [[ "${line}" =~ ${RELEASE} ]]
           then
              ${DEBUG} && log $0 "${FUNCTION_MODIFIER_A_EVENT}: Released"
              FN_A_PRESSED=false
           fi
        ;;
        (${FUNCTION_MODIFIER_B_EVENT})
           if [[ "${line}" =~ ${PRESS} ]]
           then
              ${DEBUG} && log $0 "${FUNCTION_MODIFIER_B_EVENT}: Pressed"
              FN_B_PRESSED=true
           elif [[ "${line}" =~ ${RELEASE} ]]
           then
              ${DEBUG} && log $0 "${FUNCTION_MODIFIER_B_EVENT}: Released"
              FN_B_PRESSED=false
           fi
        ;;
        (${FUNCTION_HOTKEY_EVENT})
           if [[ "${line}" =~ ${PRESS} ]]
           then
              ${DEBUG} && log $0 "${FUNCTION_HOTKEY_EVENT}: Pressed"
              HOTKEY_PRESSED=true
           elif [[ "${line}" =~ ${RELEASE} ]]
           then
              ${DEBUG} && log $0 "${FUNCTION_HOTKEY_EVENT}: Released"
              HOTKEY_PRESSED=false
           fi
        ;;
        (${FUNCTION_SELECT_EVENT})
           if [[ "${line}" =~ ${PRESS} ]]
           then
              ${DEBUG} && log $0 "${FUNCTION_SELECT_EVENT}: Pressed"
              SELECT_PRESSED=true
              if [ "${HOTKEY_PRESSED}" = true ] && \
                 [ "${START_PRESSED}" = true ]
              then
                execute_kill
              fi
           elif [[ "${line}" =~ ${RELEASE} ]]
           then
              ${DEBUG} && log $0 "${FUNCTION_SELECT_EVENT}: Released"
              SELECT_PRESSED=false
           fi
        ;;
        (${FUNCTION_START_EVENT})
           if [[ "${line}" =~ ${PRESS} ]]
           then
              ${DEBUG} && log $0 "${FUNCTION_START_EVENT}: Pressed"
              START_PRESSED=true
              if [ "${HOTKEY_PRESSED}" = true ] && \
                 [ "${SELECT_PRESSED}" = true ]
              then
                execute_kill
              fi
           elif [[ "${line}" =~ ${RELEASE} ]]
           then
              ${DEBUG} && log $0 "${FUNCTION_START_EVENT}: Released"
              START_PRESSED=false
           fi
        ;;
        (${FUNCTION_VOLUME_UP_EVENT})
            execute_action up
        ;;
        (${FUNCTION_VOLUME_DOWN_EVENT})
            execute_action down
        ;;
    esac
done
